This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-02T19:25:43.671Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitattributes
Boligventilasjon_Prosjekter/main_contractors.txt
config.ini
database.py
gui/__init__.py
gui/add_project_dialog.py
gui/base_projects_tab.py
gui/completed_projects_tab.py
gui/detailed_view_tab.py
gui/finished_projects_tab.py
gui/overview_tab.py
logger.py
main.py
pdf_converter.py
project.py
promptTips.txt
requirements.txt
utils.py

================================================================
Repository Files
================================================================

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: Boligventilasjon_Prosjekter/main_contractors.txt
================
Lindal
Lohne

================
File: config.ini
================
# config.ini
[Paths]
template_dir = ./templates
project_dir = ./Boligventilasjon_Prosjekter
docx_temp_dir = ./temp_docx
logs_dir = ./logs
database_file = projects.db

================
File: database.py
================
# File: database.py
from sqlalchemy import create_engine, Column, Integer, String, Boolean, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, scoped_session
from project import Project, Unit
from logger import get_logger
import os
from configparser import ConfigParser
from PyQt5.QtCore import QObject, pyqtSignal

logger = get_logger(__name__)

# Load configuration
config = ConfigParser()
config.read('config.ini')

# Retrieve paths from config
project_dir = os.path.abspath(config['Paths'].get('project_dir', 'Boligventilasjon_Prosjekter'))
database_file = config['Paths'].get('database_file', 'projects.db')

# Ensure project_dir exists
if not os.path.exists(project_dir):
    try:
        os.makedirs(project_dir)
        logger.info(f"Created project directory at {project_dir}")
    except Exception as e:
        logger.error(f"Failed to create project directory at {project_dir}: {e}")
        raise

# Construct full database path
db_path = os.path.join(project_dir, database_file)

Base = declarative_base()

class ProjectModel(Base):
    __tablename__ = 'projects'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    number = Column(String, nullable=False)
    start_date = Column(String, nullable=False)
    end_date = Column(String, nullable=True)
    status = Column(String, nullable=False)
    is_residential_complex = Column(Boolean, default=False)
    number_of_units = Column(Integer, default=0)
    worker = Column(String, nullable=False)
    extra = Column(String, default="")
    main_contractor = Column(String, nullable=True)  # New Field
    
    units = relationship("UnitModel", back_populates="project", cascade="all, delete-orphan")

class UnitModel(Base):
    __tablename__ = 'units'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    project_id = Column(Integer, ForeignKey('projects.id'))
    name = Column(String, nullable=False)
    is_done = Column(Boolean, default=False)
    
    project = relationship("ProjectModel", back_populates="units")

class Database(QObject):
    project_updated = pyqtSignal()

    def __init__(self):
        super().__init__()
        try:
            self.engine = create_engine(f'sqlite:///{db_path}', echo=False)
            Base.metadata.create_all(self.engine)
            self.Session = scoped_session(sessionmaker(bind=self.engine))
            self.session = self.Session()
            logger.info(f"Database initialized at {db_path}")
        except Exception as e:
            logger.error(f"Failed to initialize database at {db_path}: {e}")
            raise

    def add_project(self, project: Project):
        try:
            project_model = ProjectModel(
                name=project.name,
                number=project.number,
                start_date=project.start_date,
                end_date=project.end_date,
                status=project.status,
                is_residential_complex=project.is_residential_complex,
                number_of_units=project.number_of_units,
                worker=project.worker,
                extra=project.extra,
                main_contractor=project.main_contractor  # Map New Attribute
            )
            # Add units if residential complex
            if project.is_residential_complex and project.units:
                for unit_name in project.units:
                    unit_model = UnitModel(name=unit_name)
                    project_model.units.append(unit_model)
            self.session.add(project_model)
            self.session.commit()
            logger.info(f"Added project: {project.name} ({project.number}) with ID {project_model.id}")
            self.project_updated.emit()  # Emit signal
            return project_model.id
        except Exception as e:
            logger.error(f"Failed to add project: {e}")
            self.session.rollback()
            raise

    def update_project(self, project: Project):
        try:
            project_model = self.session.query(ProjectModel).filter_by(id=project.id).first()
            if project_model:
                project_model.name = project.name
                project_model.number = project.number
                project_model.start_date = project.start_date
                project_model.end_date = project.end_date
                project_model.status = project.status
                project_model.is_residential_complex = project.is_residential_complex
                project_model.number_of_units = project.number_of_units
                project_model.worker = project.worker
                project_model.extra = project.extra
                project_model.main_contractor = project.main_contractor  # Update New Attribute
                # Update units
                if project.is_residential_complex:
                    # Clear existing units
                    project_model.units.clear()
                    # Add new units
                    if project.units:
                        for unit_name in project.units:
                            unit_model = UnitModel(name=unit_name)
                            project_model.units.append(unit_model)
                else:
                    project_model.units = []
                self.session.commit()
                logger.info(f"Updated project ID {project.id}: {project.name} ({project.number})")
                self.project_updated.emit()  # Emit signal
        except Exception as e:
            logger.error(f"Failed to update project ID {project.id}: {e}")
            self.session.rollback()
            raise

    def delete_project(self, project_id: int):
        try:
            project_model = self.session.query(ProjectModel).filter_by(id=project_id).first()
            if project_model:
                self.session.delete(project_model)
                self.session.commit()
                logger.info(f"Deleted project ID {project_id}")
                self.project_updated.emit()  # Emit signal
        except Exception as e:
            logger.error(f"Failed to delete project ID {project_id}: {e}")
            self.session.rollback()
            raise

    def load_projects(self, status=None):
        try:
            query = self.session.query(ProjectModel)
            if status is not None:
                query = query.filter_by(status=status)
            projects = query.all()
            if status is not None:
                logger.info(f"Loaded projects with status='{status}'. Count: {len(projects)}")
            else:
                logger.info(f"Loaded all projects. Count: {len(projects)}")
            return [Project(
                id=p.id,
                name=p.name,
                number=p.number,
                start_date=p.start_date,
                end_date=p.end_date,
                status=p.status,
                is_residential_complex=p.is_residential_complex,
                number_of_units=p.number_of_units,
                worker=p.worker,
                extra=p.extra,
                main_contractor=p.main_contractor,
                units=[unit.name for unit in p.units]
            ) for p in projects]
        except Exception as e:
            logger.error(f"Failed to load projects: {e}")
            raise

    def get_project_by_id(self, project_id: int):
        try:
            p = self.session.query(ProjectModel).filter_by(id=project_id).first()
            if p:
                logger.info(f"Retrieved project ID {project_id}")
                return Project(
                    id=p.id,
                    name=p.name,
                    number=p.number,
                    start_date=p.start_date,
                    end_date=p.end_date,
                    status=p.status,
                    is_residential_complex=p.is_residential_complex,
                    number_of_units=p.number_of_units,
                    worker=p.worker,
                    extra=p.extra,
                    main_contractor=p.main_contractor,
                    units=[unit.name for unit in p.units]
                )
            logger.warning(f"Project ID {project_id} not found.")
            return None
        except Exception as e:
            logger.error(f"Failed to retrieve project ID {project_id}: {e}")
            raise

    def toggle_unit_status(self, project_id: int, unit_id: int, is_done: bool):
        try:
            unit = self.session.query(UnitModel).filter_by(id=unit_id, project_id=project_id).first()
            if unit:
                unit.is_done = is_done
                self.session.commit()
                logger.info(f"Unit ID {unit_id} in Project ID {project_id} marked as {'done' if is_done else 'undone'}.")
                self.project_updated.emit()  # Emit signal
        except Exception as e:
            logger.error(f"Failed to toggle unit status for Unit ID {unit_id} in Project ID {project_id}: {e}")
            self.session.rollback()
            raise

    def close(self):
        self.session.close()
        self.Session.remove()
        logger.info("Database session closed.")

================
File: gui/__init__.py
================
# gui/__init__.py
# This file can be left empty or used for package initialization if needed.

================
File: gui/add_project_dialog.py
================
# File: gui/add_project_dialog.py
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QDateEdit,
    QComboBox, QCheckBox, QSpinBox, QPushButton, QMessageBox, QHBoxLayout, QWidget, QGridLayout
)
from PyQt5.QtCore import Qt, QDate, QThread
from gui.base_projects_tab import BaseProjectsTab
from project import Project
from utils import (
    sanitize_filename,
    get_template_dir,
    check_template_files,
    open_docx_file,
    get_project_dir,
    load_main_contractors,
    add_main_contractor,
    get_docx_temp_dir
)
from logger import get_logger
from pdf_converter import PDFConverter
from docx import Document
import os
import shutil
from datetime import datetime

logger = get_logger(__name__)

class AddProjectDialog(QDialog):
    def __init__(self, db):
        super().__init__()
        self.db = db
        self.setWindowTitle("Add New Project")
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.form_layout = QFormLayout()

        # Project Name
        self.name_input = QLineEdit()
        self.form_layout.addRow("Project Name:", self.name_input)

        # Project Number
        self.number_input = QLineEdit()
        self.form_layout.addRow("Project Number:", self.number_input)

        # Worker Selection
        self.worker_input = QComboBox()
        self.worker_input.addItems(["Alex", "William"])
        self.worker_input.setCurrentText("Alex")  # Default to "Alex"
        self.form_layout.addRow("Worker:", self.worker_input)

        # Start Date
        self.start_date_input = QDateEdit(calendarPopup=True)
        self.start_date_input.setDate(QDate.currentDate())
        self.start_date_input.setDisplayFormat("dd-MM-yyyy")
        self.form_layout.addRow("Start Date:", self.start_date_input)

        # End Date
        self.end_date_input = QDateEdit(calendarPopup=True)
        self.end_date_input.setSpecialValueText("")
        self.end_date_input.setDateRange(QDate.currentDate(), QDate(9999, 12, 31))
        self.end_date_input.setDate(QDate())  # Blank by default
        self.end_date_input.setDisplayFormat("dd-MM-yyyy")
        self.end_date_input.setEnabled(False)  # Not required to be filled in
        self.form_layout.addRow("End Date:", self.end_date_input)

        # Status Selection
        self.status_input = QComboBox()
        self.status_input.addItems(["Active", "Awaiting Completion", "Paused", "Finished"])  # Removed "Completed"
        self.status_input.setCurrentText("Active")  # Default to "Active"
        self.form_layout.addRow("Status:", self.status_input)

        # Residential Complex Checkbox
        self.residential_checkbox = QCheckBox("Residential Complex")
        self.residential_checkbox.stateChanged.connect(self.toggle_units)
        self.form_layout.addRow(self.residential_checkbox)

        # Number of Units
        self.units_input = QSpinBox()
        self.units_input.setRange(1, 1000)
        self.units_input.setEnabled(False)
        self.units_input.valueChanged.connect(self.generate_unit_name_fields)
        self.form_layout.addRow("Number of Units:", self.units_input)

        # Extra Field
        self.extra_input = QLineEdit()
        self.form_layout.addRow("Extra:", self.extra_input)

        # Main Contractor Checkbox
        self.main_contractor_checkbox = QCheckBox("Add Main Contractor")
        self.main_contractor_checkbox.stateChanged.connect(self.toggle_main_contractor)
        self.form_layout.addRow(self.main_contractor_checkbox)

        # Main Contractor ComboBox
        self.main_contractor_input = QComboBox()
        self.main_contractor_input.setEditable(True)
        self.main_contractor_input.addItems(load_main_contractors())
        self.main_contractor_input.setEnabled(False)
        self.main_contractor_input.lineEdit().setPlaceholderText("Select or enter Main Contractor")
        self.form_layout.addRow("Main Contractor:", self.main_contractor_input)

        # Unit Names Layout
        self.unit_names_widget = QWidget()
        self.unit_names_layout = QVBoxLayout()
        self.unit_names_widget.setLayout(self.unit_names_layout)
        self.unit_names_widget.setVisible(False)
        self.form_layout.addRow("Unit Names:", self.unit_names_widget)

        self.unit_line_edits = []  # Initialize here to prevent AttributeError

        self.layout.addLayout(self.form_layout)

        # Buttons Layout
        self.button_layout = QHBoxLayout()
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.save_project)
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        self.button_layout.addWidget(self.save_btn)
        self.button_layout.addWidget(self.cancel_btn)
        self.layout.addLayout(self.button_layout)

    def toggle_units(self, state):
        is_checked = state == Qt.Checked
        self.units_input.setEnabled(is_checked)
        self.unit_names_widget.setVisible(is_checked)
        if not is_checked:
            # Clear unit names fields
            for i in reversed(range(self.unit_names_layout.count())):
                widget_to_remove = self.unit_names_layout.itemAt(i).widget()
                if widget_to_remove is not None:
                    widget_to_remove.setParent(None)
            self.unit_line_edits = []  # Reset the list

    def toggle_main_contractor(self, state):
        is_checked = state == Qt.Checked
        self.main_contractor_input.setEnabled(is_checked)

    def generate_unit_name_fields(self, value):
        # Clear existing fields
        for i in reversed(range(self.unit_names_layout.count())):
            widget_to_remove = self.unit_names_layout.itemAt(i).widget()
            if widget_to_remove is not None:
                widget_to_remove.setParent(None)
        # Generate new fields
        self.unit_line_edits = []
        for i in range(1, value + 1):
            line_edit = QLineEdit()
            line_edit.setText(str(i))
            self.unit_names_layout.addWidget(line_edit)
            self.unit_line_edits.append(line_edit)

    def save_project(self):
        # Gather data from input fields
        name = self.name_input.text().strip()
        number = self.number_input.text().strip()
        worker = self.worker_input.currentText().strip()
        start_date = self.start_date_input.date().toPyDate()
        # Ensure end_date is None upon creation
        end_date = None  # Always None when adding a new project
        status = self.status_input.currentText()
        is_residential = self.residential_checkbox.isChecked()
        units = []
        if is_residential:
            for line_edit in self.unit_line_edits:
                unit_name = line_edit.text().strip()
                if unit_name:
                    units.append(unit_name)
        extra = self.extra_input.text().strip()

        # Main Contractor
        main_contractor = self.main_contractor_input.currentText().strip() if self.main_contractor_checkbox.isChecked() else None

        # Validation
        if not name and not number:
            QMessageBox.warning(self, "Validation Error", "At least one of Project Name or Project Number must be provided.")
            return

        if is_residential:
            if not units:
                QMessageBox.warning(self, "Validation Error", "At least one unit name must be provided for a residential complex.")
                return
            if len(units) != self.units_input.value():
                QMessageBox.warning(self, "Validation Error", "Number of unit names does not match the number of units specified.")
                return
            if len(units) != len(set(units)):
                QMessageBox.warning(self, "Validation Error", "Unit names must be unique.")
                return

        if main_contractor:
            if main_contractor not in load_main_contractors():
                # Ask user to confirm adding a new contractor
                reply = QMessageBox.question(
                    self,
                    "Add New Contractor",
                    f"'{main_contractor}' is not in the existing list. Do you want to add it?",
                    QMessageBox.Yes | QMessageBox.No
                )
                if reply == QMessageBox.Yes:
                    try:
                        add_main_contractor(main_contractor)
                        QMessageBox.information(self, "Success", f"'{main_contractor}' has been added to the Main Contractors list.")
                        # Update the ComboBox with the new contractor
                        self.main_contractor_input.addItem(main_contractor)
                        logger.info(f"Added new main contractor: {main_contractor}")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to add new contractor: {str(e)}")
                        logger.error(f"Failed to add main contractor '{main_contractor}': {e}")
                        return

        # Create Project instance without 'id' and ensure end_date is None
        project = Project(
            name=name,
            number=number,
            start_date=start_date.strftime("%Y-%m-%d"),
            end_date=None,  # Explicitly set to None
            status=status,
            is_residential_complex=is_residential,
            number_of_units=self.units_input.value() if is_residential else 0,
            worker=worker,
            extra=extra,
            main_contractor=main_contractor,  # Set New Attribute
            units=units  # Set Unit Names
        )

        # Add project to database
        try:
            project_id = self.db.add_project(project)
            logger.info(f"Project '{project.name}' with ID {project_id} added successfully. Residential Complex: {is_residential}")
        except Exception as e:
            QMessageBox.critical(self, "Database Error", f"Failed to add project: {str(e)}")
            logger.error(f"Failed to add project '{project.name}': {e}")
            return

        # Create Project Folder
        folder_name = ""
        if main_contractor:
            folder_name = sanitize_filename(f"{main_contractor} - {name} - {number}") if (name or number) else f"{main_contractor} - Project_{project_id}"
        else:
            folder_name = sanitize_filename(f"{name}_{number}") if (name or number) else f"Project_{project_id}"
        project_folder = os.path.join(get_project_dir(), folder_name)
        try:
            os.makedirs(project_folder, exist_ok=True)
            logger.info(f"Created project folder at {project_folder}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to create project folder:\n{str(e)}")
            logger.error(f"Failed to create project folder at {project_folder}: {e}")
            return

        # Create "Floor plan" subfolder
        floor_plan_folder = os.path.join(project_folder, "Floor plan")
        try:
            os.makedirs(floor_plan_folder, exist_ok=True)
            logger.info(f"Created 'Floor plan' folder at {floor_plan_folder}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to create 'Floor plan' folder:\n{str(e)}")
            logger.error(f"Failed to create 'Floor plan' folder at {floor_plan_folder}: {e}")
            return

        # Check for Template directory and required files
        valid, message = check_template_files()
        if not valid:
            QMessageBox.critical(self, "Template Error", message)
            logger.error(f"Template check failed: {message}")
            return

        # Define Template directory path
        template_dir = get_template_dir()

        # Copy the required template files into the project folder if not residential complex
        if not is_residential:
            try:
                required_files = ["Innregulering.docx", "Sjekkliste.docx"]
                for file in required_files:
                    shutil.copy(os.path.join(template_dir, file), project_folder)
                logger.info(f"Copied templates to {project_folder}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to copy template files:\n{str(e)}")
                logger.error(f"Failed to copy templates to {project_folder}: {e}")
                return

        # Create subfolders for each unit with their own DOCX files
        if is_residential and units:
            for unit in units:
                unit_folder = os.path.join(project_folder, sanitize_filename(unit))
                try:
                    os.makedirs(unit_folder, exist_ok=True)
                    logger.info(f"Created unit folder at {unit_folder}")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to create unit folder '{unit}':\n{str(e)}")
                    logger.error(f"Failed to create unit folder '{unit}' at {unit_folder}: {e}")
                    return
                # Create "Floor plan" subfolder inside unit folder
                floor_plan_subfolder = os.path.join(unit_folder, "Floor plan")
                try:
                    os.makedirs(floor_plan_subfolder, exist_ok=True)
                    logger.info(f"Created 'Floor plan' subfolder at {floor_plan_subfolder}")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to create 'Floor plan' subfolder for unit '{unit}':\n{str(e)}")
                    logger.error(f"Failed to create 'Floor plan' subfolder for unit '{unit}' at {floor_plan_subfolder}: {e}")
                    return
                # Create DOCX files for the unit using templates
                try:
                    innregulering_path = os.path.join(unit_folder, "Innregulering.docx")
                    sjekkliste_path = os.path.join(unit_folder, "Sjekkliste.docx")
                    shutil.copy(os.path.join(template_dir, "Innregulering.docx"), innregulering_path)
                    shutil.copy(os.path.join(template_dir, "Sjekkliste.docx"), sjekkliste_path)
                    logger.info(f"Copied Innregulering and Sjekkliste DOCX to {unit_folder}")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to copy DOCX files for unit '{unit}':\n{str(e)}")
                    logger.error(f"Failed to copy DOCX files for unit '{unit}' in folder '{unit_folder}': {e}")
                    return

        # Optional: Initiate PDF conversion if needed
        # self.convert_pdf(project)

        # Removed the following line as per instruction:
        # QMessageBox.information(self, "Success", "Project added successfully.")
        
        logger.info(f"Project added successfully: {project.name} ({project.number})")
        self.accept()

    def convert_pdf(self, project):
        # Example method to convert a related Excel file to PDF
        excel_path = os.path.join(get_project_dir(), sanitize_filename(f"{project.name}_{project.number}"), "Data.xlsx")
        pdf_path = os.path.join(get_docx_temp_dir(), f"{project.name}_{project.number}_Data.pdf")

        self.converter = PDFConverter(excel_path, pdf_path)
        self.thread = QThread()
        self.converter.moveToThread(self.thread)
        self.converter.conversion_complete.connect(self.on_conversion_complete)
        self.converter.conversion_failed.connect(self.on_conversion_failed)
        self.thread.started.connect(self.converter.run_conversion)
        self.converter.conversion_complete.connect(self.thread.quit)
        self.converter.conversion_failed.connect(self.thread.quit)
        self.thread.start()

    def on_conversion_complete(self, pdf_path):
        QMessageBox.information(self, "Conversion Complete", f"PDF saved at {pdf_path}")
        logger.info(f"PDF conversion completed: {pdf_path}")

    def on_conversion_failed(self, error_message):
        QMessageBox.critical(self, "Conversion Failed", f"Failed to convert PDF:\n{error_message}")
        logger.error(f"PDF conversion failed: {error_message}")

================
File: gui/base_projects_tab.py
================
# File: gui/base_projects_tab.py
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QToolButton, QMenu, QAction, QTreeWidget, QTreeWidgetItem, 
    QHBoxLayout, QMessageBox, QCheckBox, QPushButton, QFileDialog
)
from PyQt5.QtGui import QColor
from PyQt5.QtCore import Qt, QPoint
from datetime import datetime
import os
import sys
import subprocess
import shutil
import tempfile
from logger import get_logger
from utils import sanitize_filename, open_docx_file, get_project_dir, get_template_dir
from docx import Document
from docx.enum.section import WD_ORIENT
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Inches
from database import UnitModel, ProjectModel  # Ensure ProjectModel is also imported

logger = get_logger(__name__)

class BaseProjectsTab(QWidget):
    def __init__(self, db, status_filter=None, title=""):
        super().__init__()
        self.db = db
        self.status_filter = status_filter
        self.title = title
        self.template_dir = get_template_dir()  # Added this line
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)
        self.setup_ui()
        self.load_projects()

    def setup_ui(self):
        # Buttons Layout
        self.buttons_layout = QHBoxLayout()
        
        # View DOCX Split Button (default action is now View DOCX)
        self.view_docx_split_btn = QToolButton()
        self.view_docx_split_btn.setText("View DOCX")
        self.view_docx_split_btn.setToolTip(f"View {self.title} DOCX")
        self.view_docx_split_btn.setPopupMode(QToolButton.MenuButtonPopup)

        # Create menu with only "Save As..." option
        self.view_docx_menu = QMenu(self)
        self.save_as_action = QAction("Save As...", self)
        self.save_as_action.triggered.connect(self.save_docx_overview)
        self.view_docx_menu.addAction(self.save_as_action)

        # Set the default button click to trigger "View DOCX"
        self.view_docx_split_btn.clicked.connect(self.view_docx_overview)
        self.view_docx_split_btn.setMenu(self.view_docx_menu)

        self.buttons_layout.addWidget(self.view_docx_split_btn)

        self.layout.addLayout(self.buttons_layout)

        # Projects Tree
        self.tree = QTreeWidget()
        self.tree.setHeaderLabels([
            "Project Name",
            "Project Number",
            "Main Contractor",
            "Completed Units",
            "Status",
            "Extra",
            "Innregulering",
            "Sjekkliste",
            "Floor Plan(s)",
            "Move(1)",
            "Move(2)",
            "Start Date",
            "End Date",
            "Worker"
        ])
        self.tree.setColumnCount(14)
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.open_context_menu)
        self.layout.addWidget(self.tree)

        # Temporary DOCX path
        self.docx_path = os.path.join(tempfile.gettempdir(), f"{sanitize_filename(self.title)}_Projects.docx")

    def load_projects(self):
        self.tree.clear()
        projects = self.db.load_projects(status=self.status_filter)
        logger.info(f"Loading {len(projects)} projects into the '{self.title}' tab.")
        for project in projects:
            project_item = QTreeWidgetItem([
                project.name,
                project.number,
                project.main_contractor if project.main_contractor else "",
                "",
                project.status,
                project.extra if project.extra else "",
                "",
                "",
                "",
                "",
                "",
                self.format_date(project.start_date),
                self.format_date(project.end_date) if project.end_date else "",
                project.worker
            ])
            project_item.setData(0, Qt.UserRole, project.id)
            self.tree.addTopLevelItem(project_item)
            if project.is_residential_complex and project.units:
                # Calculate completed units
                completed = self.db.session.query(UnitModel).filter_by(project_id=project.id, is_done=True).count()
                total = len(project.units)
                project_item.setText(3, f"{completed}/{total}")

                for unit_name in project.units:
                    unit_item = QTreeWidgetItem([
                        unit_name,
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        ""
                    ])
                    # Add a checkbox for done/undone
                    checkbox = QCheckBox()
                    # Retrieve the unit model to get its current status
                    unit_model = self.db.session.query(UnitModel).filter_by(project_id=project.id, name=unit_name).first()
                    if unit_model:
                        checkbox.setChecked(unit_model.is_done)
                    # Use a lambda with default arguments to capture current project and unit_name
                    checkbox.stateChanged.connect(lambda state, p=project, u=unit_name: self.toggle_unit_status(p, u, state))
                    self.tree.setItemWidget(unit_item, 0, checkbox)
                    project_item.addChild(unit_item)

                    # Innregulering Split Button for Unit
                    innregulering_split_btn = QToolButton()
                    innregulering_split_btn.setText("View")
                    innregulering_split_btn.setToolTip("View Innregulering DOCX")
                    innregulering_split_btn.setPopupMode(QToolButton.MenuButtonPopup)
                    innregulering_menu = QMenu(self)
                    innregulering_save_as_action = QAction("Save As...", self)
                    innregulering_save_as_action.triggered.connect(lambda checked, p=project, u=unit_name: self.save_docx_as(p, "Innregulering", u))
                    innregulering_menu.addAction(innregulering_save_as_action)
                    innregulering_split_btn.setMenu(innregulering_menu)
                    innregulering_split_btn.clicked.connect(lambda checked, p=project, u=unit_name: self.view_docx(p, "Innregulering", u))
                    self.tree.setItemWidget(unit_item, 6, innregulering_split_btn)

                    # Sjekkliste Split Button for Unit
                    sjekkliste_split_btn = QToolButton()
                    sjekkliste_split_btn.setText("View")
                    sjekkliste_split_btn.setToolTip("View Sjekkliste DOCX")
                    sjekkliste_split_btn.setPopupMode(QToolButton.MenuButtonPopup)
                    sjekkliste_menu = QMenu(self)
                    sjekkliste_save_as_action = QAction("Save As...", self)
                    sjekkliste_save_as_action.triggered.connect(lambda checked, p=project, u=unit_name: self.save_docx_as(p, "Sjekkliste", u))
                    sjekkliste_menu.addAction(sjekkliste_save_as_action)
                    sjekkliste_split_btn.setMenu(sjekkliste_menu)
                    sjekkliste_split_btn.clicked.connect(lambda checked, p=project, u=unit_name: self.view_docx(p, "Sjekkliste", u))
                    self.tree.setItemWidget(unit_item, 7, sjekkliste_split_btn)

                    # Floor Plan(s) Split Button for Unit
                    floor_plan_split_btn = QToolButton()
                    floor_plan_split_btn.setText("View")
                    floor_plan_split_btn.setToolTip("View Floor Plan(s)")
                    floor_plan_split_btn.setPopupMode(QToolButton.MenuButtonPopup)
                    floor_plan_menu = QMenu(self)
                    import_pdf_action = QAction("Import PDF", self)
                    import_pdf_action.triggered.connect(lambda checked, p=project, u=unit_name: self.import_floor_plan(p, u))
                    save_as_floor_plan_action = QAction("Save As...", self)
                    save_as_floor_plan_action.triggered.connect(lambda checked, p=project, u=unit_name: self.save_floor_plan_as(p, u))
                    floor_plan_menu.addAction(import_pdf_action)
                    floor_plan_menu.addAction(save_as_floor_plan_action)
                    floor_plan_split_btn.setMenu(floor_plan_menu)
                    floor_plan_split_btn.clicked.connect(lambda checked, p=project, u=unit_name: self.view_floor_plan(p, u))
                    self.tree.setItemWidget(unit_item, 8, floor_plan_split_btn)

                # Expand the project item to show unit names by default
                self.tree.expandItem(project_item)
                
                # Create project folder
                folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                project_folder = os.path.join(get_project_dir(), folder_name)
                if not os.path.exists(project_folder):
                    os.makedirs(project_folder)
                    logger.info(f"Created project folder at {project_folder}")

                # Create subfolders for each unit with their own DOCX files
                for unit in project.units:
                    unit_folder = os.path.join(project_folder, sanitize_filename(unit))
                    if not os.path.exists(unit_folder):
                        os.makedirs(unit_folder)
                        logger.info(f"Created unit folder at {unit_folder}")
                    # Create "Floor plan" subfolder inside unit folder
                    floor_plan_subfolder = os.path.join(unit_folder, "Floor plan")
                    try:
                        os.makedirs(floor_plan_subfolder, exist_ok=True)
                        logger.info(f"Created 'Floor plan' subfolder at {floor_plan_subfolder}")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to create 'Floor plan' subfolder for unit '{unit}':\n{str(e)}")
                        logger.error(f"Failed to create 'Floor plan' subfolder for unit '{unit}' at {floor_plan_subfolder}: {e}")
                        return
                    # Create DOCX files for the unit using templates
                    try:
                        innregulering_path = os.path.join(unit_folder, "Innregulering.docx")
                        sjekkliste_path = os.path.join(unit_folder, "Sjekkliste.docx")
                        shutil.copy(os.path.join(self.template_dir, "Innregulering.docx"), innregulering_path)
                        shutil.copy(os.path.join(self.template_dir, "Sjekkliste.docx"), sjekkliste_path)
                        logger.info(f"Copied Innregulering and Sjekkliste DOCX to {unit_folder}")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to copy DOCX files for unit '{unit}':\n{str(e)}")
                        logger.error(f"Failed to copy DOCX files for unit '{unit}' in folder '{unit_folder}': {e}")
                        return

            else:
                # Create project folder
                folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                project_folder = os.path.join(get_project_dir(), folder_name)
                if not os.path.exists(project_folder):
                    os.makedirs(project_folder)
                    logger.info(f"Created project folder at {project_folder}")

                # Create Innregulering and Sjekkliste DOCX in parent folder
                innregulering_path = os.path.join(project_folder, "Innregulering.docx")
                sjekkliste_path = os.path.join(project_folder, "Sjekkliste.docx")
                if not os.path.exists(innregulering_path):
                    Document().save(innregulering_path)
                    logger.info(f"Created Innregulering DOCX at {innregulering_path}")
                if not os.path.exists(sjekkliste_path):
                    Document().save(sjekkliste_path)
                    logger.info(f"Created Sjekkliste DOCX at {sjekkliste_path}")

                # Innregulering Split Button
                innregulering_split_btn = QToolButton()
                innregulering_split_btn.setText("View")
                innregulering_split_btn.setToolTip("View Innregulering DOCX")
                innregulering_split_btn.setPopupMode(QToolButton.MenuButtonPopup)
                innregulering_menu = QMenu(self)
                innregulering_save_as_action = QAction("Save As...", self)
                innregulering_save_as_action.triggered.connect(lambda checked, p=project: self.save_docx_as(p, "Innregulering"))
                innregulering_menu.addAction(innregulering_save_as_action)
                innregulering_split_btn.setMenu(innregulering_menu)
                innregulering_split_btn.clicked.connect(lambda checked, p=project: self.view_docx(p, "Innregulering"))
                self.tree.setItemWidget(project_item, 6, innregulering_split_btn)

                # Sjekkliste Split Button
                sjekkliste_split_btn = QToolButton()
                sjekkliste_split_btn.setText("View")
                sjekkliste_split_btn.setToolTip("View Sjekkliste DOCX")
                sjekkliste_split_btn.setPopupMode(QToolButton.MenuButtonPopup)
                sjekkliste_menu = QMenu(self)
                sjekkliste_save_as_action = QAction("Save As...", self)
                sjekkliste_save_as_action.triggered.connect(lambda checked, p=project: self.save_docx_as(p, "Sjekkliste"))
                sjekkliste_menu.addAction(sjekkliste_save_as_action)
                sjekkliste_split_btn.setMenu(sjekkliste_menu)
                sjekkliste_split_btn.clicked.connect(lambda checked, p=project: self.view_docx(p, "Sjekkliste"))
                self.tree.setItemWidget(project_item, 7, sjekkliste_split_btn)

                # Floor Plan(s) Split Button for Project
                floor_plan_split_btn = QToolButton()
                floor_plan_split_btn.setText("View")
                floor_plan_split_btn.setToolTip("View Floor Plan(s)")
                floor_plan_split_btn.setPopupMode(QToolButton.MenuButtonPopup)
                floor_plan_menu = QMenu(self)
                import_floor_plan_action = QAction("Import PDF", self)
                import_floor_plan_action.triggered.connect(lambda checked, p=project: self.import_floor_plan(p))
                save_as_floor_plan_action = QAction("Save As...", self)
                save_as_floor_plan_action.triggered.connect(lambda checked, p=project: self.save_floor_plan_as(p))
                floor_plan_menu.addAction(import_floor_plan_action)
                floor_plan_menu.addAction(save_as_floor_plan_action)
                floor_plan_split_btn.setMenu(floor_plan_menu)
                floor_plan_split_btn.clicked.connect(lambda checked, p=project: self.view_floor_plan(p))
                self.tree.setItemWidget(project_item, 8, floor_plan_split_btn)

                # Move(1) Button
                move1_btn = QPushButton("Active")
                move1_btn.setToolTip("Move Project to Active")
                move1_btn.setStyleSheet("background-color: yellow")
                move1_btn.clicked.connect(lambda checked, p=project: self.move_to_active(p))
                self.tree.setItemWidget(project_item, 9, move1_btn)

                # Move(2) Button
                move2_btn = QPushButton("Completed")
                move2_btn.setToolTip("Move Project to Completed")
                move2_btn.setStyleSheet("background-color: green")
                move2_btn.clicked.connect(lambda checked, p=project: self.move_to_completed(p))
                self.tree.setItemWidget(project_item, 10, move2_btn)

                if not project.is_residential_complex:
                    # Set Completed Units to N/A
                    project_item.setText(3, "N/A")

                logger.debug(f"Added project '{project.name}' with status '{project.status}' to the tree.")

    def open_context_menu(self, position: QPoint):
        item = self.tree.itemAt(position)
        if item and not item.parent():
            menu = QMenu(self)
            edit_action = QAction("Edit", self)
            delete_action = QAction("Delete", self)
            menu.addAction(edit_action)
            menu.addAction(delete_action)
            action = menu.exec_(self.tree.viewport().mapToGlobal(position))
            if action == edit_action:
                # Placeholder for Edit functionality
                pass
            elif action == delete_action:
                project_id = item.data(0, Qt.UserRole)
                project = self.db.get_project_by_id(project_id)
                if project:
                    reply = QMessageBox.question(
                        self,
                        "Confirm Deletion",
                        f"Are you sure you want to delete project '{project.name}'?",
                        QMessageBox.Yes | QMessageBox.No
                    )
                    if reply == QMessageBox.Yes:
                        try:
                            # Delete project folder
                            folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                            project_folder = os.path.join(get_project_dir(), folder_name)
                            if os.path.exists(project_folder):
                                shutil.rmtree(project_folder)
                                logger.info(f"Deleted project folder at {project_folder}")
                            # Delete project from database
                            self.db.delete_project(project.id)
                            self.load_projects()
                            QMessageBox.information(self, "Deleted", f"Project '{project.name}' has been deleted.")
                            logger.info(f"Deleted project '{project.name}' with ID {project.id}")
                        except Exception as e:
                            QMessageBox.critical(self, "Error", f"Failed to delete project: {str(e)}")
                            logger.error(f"Failed to delete project ID {project.id}: {e}")

    def view_docx_overview(self):
        # This method is called from the "View DOCX" action in the split button
        # Implement logic to open the current tab's DOCX file
        self.generate_docx()
        if not os.path.exists(self.docx_path):
            QMessageBox.warning(self, "DOCX Error", f"{self.title} DOCX does not exist.")
            logger.warning(f"{self.title} DOCX not found.")
            return

        success, message = open_docx_file(self.docx_path)
        if not success:
            QMessageBox.warning(self, "DOCX Error", message)
            logger.error(f"Failed to open {self.title} DOCX: {message}")

    def save_docx_overview(self):
        # This method is called from the "Save As..." action in the split button
        self.generate_docx()
        options = QFileDialog.Options()
        save_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save Overview As...",
            f"{sanitize_filename(self.title)}_Projects.docx",
            "Word Documents (*.docx)",
            options=options
        )
        if save_path:
            try:
                shutil.copy(self.docx_path, save_path)
                QMessageBox.information(self, "Success", f"Overview saved successfully at:\n{save_path}")
                logger.info(f"Overview saved as {save_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save Overview:\n{str(e)}")
                logger.error(f"Failed to save Overview DOCX: {e}")

    def generate_docx(self):
        try:
            document = Document()
            
            # Set page orientation to landscape
            section = document.sections[0]
            section.orientation = WD_ORIENT.LANDSCAPE
            new_width, new_height = section.page_height, section.page_width
            section.page_width = new_width
            section.page_height = new_height

            # Add header
            header = section.header
            header_para = header.paragraphs[0]
            header_para.text = self.title
            header_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add table
            projects = self.db.load_projects(status=self.status_filter)
            if not projects:
                document.add_paragraph("No projects to display.")
            else:
                table = document.add_table(rows=1, cols=8)
                table.style = 'Light List Accent 1'
                hdr_cells = table.rows[0].cells
                hdr_cells[0].text = 'Project Name'
                hdr_cells[1].text = 'Project Number'
                hdr_cells[2].text = 'Main Contractor'
                hdr_cells[3].text = 'Completed Units'
                hdr_cells[4].text = 'Status'
                hdr_cells[5].text = 'Start Date'
                hdr_cells[6].text = 'End Date'
                hdr_cells[7].text = 'Worker'

                for project in projects:
                    row_cells = table.add_row().cells
                    row_cells[0].text = project.name
                    row_cells[1].text = project.number
                    row_cells[2].text = project.main_contractor if project.main_contractor else "N/A"
                    if project.is_residential_complex:
                        completed = self.db.session.query(UnitModel).filter_by(project_id=project.id, is_done=True).count()
                        total = len(project.units)
                        row_cells[3].text = f"{completed}/{total}"
                    else:
                        row_cells[3].text = "N/A"
                    row_cells[4].text = project.status
                    row_cells[5].text = self.format_date(project.start_date)
                    row_cells[6].text = self.format_date(project.end_date) if project.end_date else "N/A"
                    row_cells[7].text = project.worker

                # Adjust column widths to fit the page
                widths = [Inches(1.5), Inches(1.0), Inches(1.5), Inches(1.2), Inches(1.0), Inches(1.0), Inches(1.0), Inches(1.2)]
                for row in table.rows:
                    for idx, width in enumerate(widths):
                        row.cells[idx].width = width

            # Add footer with current date
            footer = section.footer
            footer_para = footer.paragraphs[0]
            footer_para.text = datetime.now().strftime("%d-%m-%Y")
            footer_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT

            document.save(self.docx_path)
            logger.info(f"Generated DOCX at {self.docx_path}")
        except Exception as e:
            QMessageBox.critical(self, "DOCX Generation Error", f"Failed to generate DOCX:\n{str(e)}")
            logger.error(f"Failed to generate DOCX at {self.docx_path}: {e}")

    def save_docx_as(self, project, doc_type, unit_name=None):
        options = QFileDialog.Options()
        if unit_name:
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                f"Save {doc_type} As for {unit_name}...",
                f"{sanitize_filename(project.name)}_{sanitize_filename(unit_name)}_{doc_type}.docx",
                "Word Documents (*.docx)",
                options=options
            )
        else:
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                f"Save {doc_type} As...",
                f"{sanitize_filename(project.name)}_{doc_type}.docx",
                "Word Documents (*.docx)",
                options=options
            )
        if save_path:
            try:
                if unit_name:
                    folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                    project_folder = os.path.join(get_project_dir(), folder_name)
                    unit_folder = os.path.join(project_folder, sanitize_filename(unit_name))
                    src_file = os.path.join(unit_folder, f"{doc_type}.docx")
                else:
                    folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                    project_folder = os.path.join(get_project_dir(), folder_name)
                    src_file = os.path.join(project_folder, f"{doc_type}.docx")
                shutil.copy(src_file, save_path)
                QMessageBox.information(self, "Success", f"{doc_type} saved successfully at:\n{save_path}")
                logger.info(f"{doc_type} saved as {save_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save {doc_type}:\n{str(e)}")
                logger.error(f"Failed to save {doc_type} for project ID {project.id}: {e}")

    def toggle_unit_status(self, project, unit_name, state):
        is_done = state == Qt.Checked
        # Fetch unit by name and project
        unit = self.db.session.query(UnitModel).join(ProjectModel).filter(
            ProjectModel.id == project.id,
            UnitModel.name == unit_name
        ).first()
        if unit:
            try:
                self.db.toggle_unit_status(project.id, unit.id, is_done)
                self.load_projects()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to update unit status: {str(e)}")
                logger.error(f"Failed to update unit status for Unit '{unit_name}' in Project ID {project.id}: {e}")

    def format_date(self, date_str):
        try:
            return datetime.strptime(date_str, "%Y-%m-%d").strftime("%d-%m-%Y")
        except:
            return date_str

    def view_docx(self, project, doc_type, unit_name=None):
        if unit_name:
            folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
            docx_file = os.path.join(get_project_dir(), folder_name, sanitize_filename(unit_name), f"{doc_type}.docx")
        else:
            folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
            docx_file = os.path.join(get_project_dir(), folder_name, f"{doc_type}.docx")

        if not os.path.exists(docx_file):
            QMessageBox.warning(self, "DOCX Error", f"{doc_type}.docx does not exist for this {'unit ' + unit_name if unit_name else 'project'}.")
            logger.warning(f"{doc_type}.docx not found for project ID {project.id}" + (f" and unit '{unit_name}'." if unit_name else "."))
            return

        success, message = open_docx_file(docx_file)
        if not success:
            QMessageBox.warning(self, "DOCX Error", message)
            logger.error(f"Failed to open {doc_type}.docx for project ID {project.id}" + (f" and unit '{unit_name}': {message}" if unit_name else f": {message}"))

    def import_floor_plan(self, project, unit_name=None):
            options = QFileDialog.Options()
            if unit_name:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    f"Import Floor Plan PDF for {unit_name}",
                    "",
                    "PDF Files (*.pdf)",
                    options=options
                )
                if file_path:
                    try:
                        folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                        unit_folder = os.path.join(get_project_dir(), folder_name, sanitize_filename(unit_name), "Floor plan")
                        target_file = os.path.join(unit_folder, f"{sanitize_filename(project.name)}_FloorPlan.pdf")
                        shutil.copy(file_path, target_file)
                        QMessageBox.information(self, "Success", f"Floor Plan imported successfully to '{target_file}'.")
                        logger.info(f"Imported Floor Plan PDF to {target_file}")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to import Floor Plan PDF:\n{str(e)}")
                        logger.error(f"Failed to import Floor Plan PDF for unit '{unit_name}' in project '{project.name}': {e}")
            else:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Import Floor Plan PDF",
                    "",
                    "PDF Files (*.pdf)",
                    options=options
                )
                if file_path:
                    try:
                        folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                        floor_plan_folder = os.path.join(get_project_dir(), folder_name, "Floor plan")
                        target_file = os.path.join(floor_plan_folder, f"{sanitize_filename(project.name)}_FloorPlan.pdf")
                        shutil.copy(file_path, target_file)
                        QMessageBox.information(self, "Success", f"Floor Plan imported successfully to '{target_file}'.")
                        logger.info(f"Imported Floor Plan PDF to {target_file}")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to import Floor Plan PDF:\n{str(e)}")
                        logger.error(f"Failed to import Floor Plan PDF for project '{project.name}': {e}")


    def save_floor_plan_as(self, project, unit_name=None):
        options = QFileDialog.Options()
        if unit_name:
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                f"Save Floor Plan As for {unit_name}...",
                f"{sanitize_filename(project.name)}_{sanitize_filename(unit_name)}_FloorPlan.pdf",
                "PDF Files (*.pdf)",
                options=options
            )
        else:
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save Floor Plan As...",
                f"{sanitize_filename(project.name)}_FloorPlan.pdf",
                "PDF Files (*.pdf)",
                options=options
            )
        if save_path:
            try:
                if unit_name:
                    folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                    floor_plan_file = os.path.join(get_project_dir(), folder_name, sanitize_filename(unit_name), "Floor plan", f"{sanitize_filename(project.name)}_FloorPlan.pdf")
                else:
                    folder_name = sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}") if project.main_contractor and project.main_contractor.lower() != "none" else sanitize_filename(f"{project.name}_{project.number}")
                    floor_plan_file = os.path.join(get_project_dir(), folder_name, "Floor plan", f"{sanitize_filename(project.name)}_FloorPlan.pdf")
                if not os.path.exists(floor_plan_file):
                    QMessageBox.warning(self, "File Not Found", "Floor Plan PDF does not exist.")
                    logger.warning(f"Floor Plan PDF not found for project '{project.name}'" + (f" and unit '{unit_name}'." if unit_name else "."))
                    return
                shutil.copy(floor_plan_file, save_path)
                QMessageBox.information(self, "Success", f"Floor Plan saved successfully at:\n{save_path}")
                logger.info(f"Floor Plan saved as {save_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save Floor Plan:\n{str(e)}")
                logger.error(f"Failed to save Floor Plan for project '{project.name}'" + (f" and unit '{unit_name}': {e}" if unit_name else f": {e}"))

    def view_floor_plan(self, project, unit_name=None):
            if unit_name:
                floor_plan_file = os.path.join(
                    get_project_dir(),
                    sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}"),
                    sanitize_filename(unit_name),
                    "Floor plan",
                    f"{sanitize_filename(project.name)}_FloorPlan.pdf"
                )
            else:
                floor_plan_file = os.path.join(
                    get_project_dir(),
                    sanitize_filename(f"{project.main_contractor} - {project.name} - {project.number}"),
                    "Floor plan",
                    f"{sanitize_filename(project.name)}_FloorPlan.pdf"
                )

            if not os.path.exists(floor_plan_file):
                QMessageBox.warning(self, "Floor Plan Error", "Floor Plan PDF does not exist.")
                logger.warning(f"Floor Plan PDF not found for project '{project.name}'" + (f" and unit '{unit_name}'." if unit_name else "."))
                return

            try:
                if sys.platform == "win32":
                    os.startfile(floor_plan_file)
                elif sys.platform == "darwin":
                    subprocess.call(["open", floor_plan_file])
                else:
                    subprocess.call(["xdg-open", floor_plan_file])
                logger.info(f"Opened Floor Plan PDF: {floor_plan_file}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to open Floor Plan PDF:\n{str(e)}")
                logger.error(f"Failed to open Floor Plan PDF '{floor_plan_file}': {e}")

================
File: gui/completed_projects_tab.py
================
# File: gui/completed_projects_tab.py
from gui.base_projects_tab import BaseProjectsTab
from logger import get_logger

logger = get_logger(__name__)

class CompletedProjectsTab(BaseProjectsTab):
    def __init__(self, db):
        super().__init__(db, status_filter="Completed", title="Completed Projects")
        self.db.project_updated.connect(self.load_projects)

================
File: gui/detailed_view_tab.py
================
# File: gui/detailed_view_tab.py
from gui.base_projects_tab import BaseProjectsTab
from logger import get_logger

logger = get_logger(__name__)

class DetailedViewTab(BaseProjectsTab):
    def __init__(self, db):
        super().__init__(db, status_filter=None, title="Detailed Project View")
        self.current_project = None
        # Removed setup_add_project_ui to eliminate the Add New Project button from this tab
        self.db.project_updated.connect(self.load_projects)
        logger.info("DetailedViewTab initialized and connected to project_updated signal.")

================
File: gui/finished_projects_tab.py
================
# File: gui/finished_projects_tab.py
from gui.base_projects_tab import BaseProjectsTab
from logger import get_logger

logger = get_logger(__name__)

class FinishedProjectsTab(BaseProjectsTab):
    def __init__(self, db):
        super().__init__(db, status_filter="Finished", title="Finished Projects")
        self.db.project_updated.connect(self.load_projects)

================
File: gui/overview_tab.py
================
# File: gui/overview_tab.py
from gui.base_projects_tab import BaseProjectsTab
from gui.add_project_dialog import AddProjectDialog
from logger import get_logger
from PyQt5.QtWidgets import QPushButton, QHBoxLayout

logger = get_logger(__name__)

class OverviewTab(BaseProjectsTab):
    def __init__(self, db):
        super().__init__(db, status_filter="Active", title="Overview Projects")
        self.setup_add_project_ui()
        self.db.project_updated.connect(self.load_projects)
        logger.info("OverviewTab initialized and connected to project_updated signal.")

    def setup_add_project_ui(self):
        # Add Project Button
        self.add_project_btn = QPushButton("Add New Project")
        self.add_project_btn.clicked.connect(self.open_add_project_dialog)
        
        # Add the button to the buttons_layout
        self.buttons_layout.addWidget(self.add_project_btn)

    def open_add_project_dialog(self):
        dialog = AddProjectDialog(self.db)
        if dialog.exec_():
            self.load_projects()
            logger.info("New project added via dialog.")

================
File: logger.py
================
# File: logger.py
import logging
import os
from logging.handlers import RotatingFileHandler
from configparser import ConfigParser

# Load configuration
config = ConfigParser()
config.read('config.ini')

# Create logs directory if it doesn't exist
logs_dir = os.path.abspath(config['Paths']['logs_dir'])
if not os.path.exists(logs_dir):
    os.makedirs(logs_dir)

def get_logger(name):
    logger = logging.getLogger(name)
    if not logger.handlers:
        logger.setLevel(logging.DEBUG)
        handler = RotatingFileHandler(
            os.path.join(logs_dir, 'app.log'),
            maxBytes=5*1024*1024,  # 5 MB
            backupCount=5
        )
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    return logger

================
File: main.py
================
# File: main.py
import sys
import os
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QMessageBox, QFileDialog, QShortcut
)
from PyQt5.QtGui import QKeySequence
from PyQt5.QtCore import Qt
from database import Database
from gui.overview_tab import OverviewTab
from gui.completed_projects_tab import CompletedProjectsTab
from gui.finished_projects_tab import FinishedProjectsTab
from gui.detailed_view_tab import DetailedViewTab
from logger import get_logger

logger = get_logger(__name__)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Boligventilasjon Project Management")
        self.resize(1200, 800)

        self.db = Database()

        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)

        # Initialize tabs
        self.overview_tab = OverviewTab(self.db)
        self.completed_projects_tab = CompletedProjectsTab(self.db)
        self.finished_projects_tab = FinishedProjectsTab(self.db)
        self.detailed_view_tab = DetailedViewTab(self.db)

        self.tabs.addTab(self.overview_tab, "  Project Overview  ")
        self.tabs.addTab(self.completed_projects_tab, "  Completed Projects  ")
        self.tabs.addTab(self.finished_projects_tab, "  Finished Projects  ")
        self.tabs.addTab(self.detailed_view_tab, "  Detailed Project View  ")

        self.setup_menu_bar()
        self.setup_shortcuts()
        self.apply_stylesheet()

    def setup_menu_bar(self):
        menu_bar = self.menuBar()

        # File Menu
        file_menu = menu_bar.addMenu("File")

        # Setup Template Action
        setup_template_action = file_menu.addAction("Setup Template")
        setup_template_action.triggered.connect(self.setup_template)

    def setup_template(self):
        """
        Handles the Setup Template functionality:
        - Creates the 'Template' folder if it doesn't exist.
        - Prompts the user to select 'Innregulering.docx' and 'Sjekkliste.docx' files.
        - Copies the selected files into the 'Template' folder.
        """
        from utils import get_template_dir
        from shutil import copy
        from logger import get_logger

        logger = get_logger(__name__)

        template_dir = get_template_dir()

        # Create 'Template' folder if it doesn't exist
        if not os.path.exists(template_dir):
            try:
                os.makedirs(template_dir)
                QMessageBox.information(self, "Template Folder Created", f"'Template' folder created at:\n{template_dir}")
                logger.info(f"Created template directory at {template_dir}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to create 'Template' folder:\n{str(e)}")
                logger.error(f"Failed to create template directory: {e}")
                return
        else:
            QMessageBox.information(self, "Template Folder Exists", f"'Template' folder already exists at:\n{template_dir}")
            logger.info(f"Template directory already exists at {template_dir}")

        # Prompt user to select 'Innregulering.docx'
        innregulering_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select 'Innregulering.docx' Template File",
            "",
            "Word Documents (*.docx)"
        )

        if not innregulering_path:
            QMessageBox.warning(self, "Operation Cancelled", "No 'Innregulering.docx' file selected.")
            logger.warning("User cancelled selecting 'Innregulering.docx'")
            return

        # Validate selected file name
        if os.path.basename(innregulering_path).lower() != "innregulering.docx":
            QMessageBox.warning(self, "Invalid File", "Please select a file named 'Innregulering.docx'.")
            logger.warning("User selected an invalid 'Innregulering.docx' file.")
            return

        # Prompt user to select 'Sjekkliste.docx'
        sjekkliste_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select 'Sjekkliste.docx' Template File",
            "",
            "Word Documents (*.docx)"
        )

        if not sjekkliste_path:
            QMessageBox.warning(self, "Operation Cancelled", "No 'Sjekkliste.docx' file selected.")
            logger.warning("User cancelled selecting 'Sjekkliste.docx'")
            return

        # Validate selected file name
        if os.path.basename(sjekkliste_path).lower() != "sjekkliste.docx":
            QMessageBox.warning(self, "Invalid File", "Please select a file named 'Sjekkliste.docx'.")
            logger.warning("User selected an invalid 'Sjekkliste.docx' file.")
            return

        # Copy the selected files into the 'Template' folder
        try:
            copy(innregulering_path, os.path.join(template_dir, "Innregulering.docx"))
            copy(sjekkliste_path, os.path.join(template_dir, "Sjekkliste.docx"))
            QMessageBox.information(self, "Success", f"Templates have been set up successfully in:\n{template_dir}")
            logger.info("Templates copied successfully.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to copy template files:\n{str(e)}")
            logger.error(f"Failed to copy templates: {e}")

    def setup_shortcuts(self):
        # Shortcuts to switch tabs
        QShortcut(QKeySequence("Alt+1"), self).activated.connect(lambda: self.tabs.setCurrentIndex(0))
        QShortcut(QKeySequence("Alt+2"), self).activated.connect(lambda: self.tabs.setCurrentIndex(1))
        QShortcut(QKeySequence("Alt+3"), self).activated.connect(lambda: self.tabs.setCurrentIndex(2))
        QShortcut(QKeySequence("Alt+4"), self).activated.connect(lambda: self.tabs.setCurrentIndex(3))

    def apply_stylesheet(self):
        """
        Applies a custom stylesheet to highlight the selected tab with a light blueish color
        and ensures bold text fits within the tab boundaries.
        Adds spacing only before the last tab.
        """
        stylesheet = """
        QTabWidget::pane { /* The tab widget frame */
            border-top: 2px solid #C2C7CB;
        }

        /* Style the tab using the tab selector */
        QTabBar::tab {
            background: lightgray;
            border: 1px solid #C4C4C3;
            padding: 10px;
            margin-right: 2px;
            min-width: 120px; /* Increased to accommodate bold text with spaces */
        }

        /* Style the selected tab */
        QTabBar::tab:selected {
            background: #ADD8E6; /* Light Blue */
            font-weight: bold;
        }

        /* Optional: Hover effect */
        QTabBar::tab:hover {
            background: #D3D3D3; /* Light Grey */
        }
        """
        self.tabs.setStyleSheet(stylesheet)

    def closeEvent(self, event):
        self.db.close()
        event.accept()

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

================
File: pdf_converter.py
================
# File: pdf_converter.py
import subprocess
import os
from PyQt5.QtCore import QObject, pyqtSignal
import sys
from logger import get_logger

logger = get_logger(__name__)

class PDFConverter(QObject):
    conversion_complete = pyqtSignal(str)
    conversion_failed = pyqtSignal(str)

    def __init__(self, excel_path, pdf_path):
        super().__init__()
        self.excel_path = excel_path
        self.pdf_path = pdf_path

    def run_conversion(self):
        try:
            if os.name == 'nt':
                import win32com.client
                excel = win32com.client.Dispatch("Excel.Application")
                excel.Visible = False
                wb = excel.Workbooks.Open(self.excel_path)
                wb.ExportAsFixedFormat(0, self.pdf_path)
                wb.Close(False)
                excel.Quit()
                logger.info(f"Converted Excel to PDF: {self.excel_path} -> {self.pdf_path}")
                self.conversion_complete.emit(self.pdf_path)
            elif sys.platform.startswith('darwin') or os.name == 'posix':
                # Use LibreOffice for macOS and Linux
                subprocess.run(['libreoffice', '--headless', '--convert-to', 'pdf', self.excel_path, '--outdir', os.path.dirname(self.pdf_path)], check=True)
                logger.info(f"Converted Excel to PDF using LibreOffice: {self.excel_path} -> {self.pdf_path}")
                self.conversion_complete.emit(self.pdf_path)
            else:
                raise OSError("Unsupported operating system for PDF conversion.")
        except Exception as e:
            logger.error(f"PDF conversion failed: {e}")
            self.conversion_failed.emit(str(e))

================
File: project.py
================
# File: project.py
from dataclasses import dataclass, field
from typing import Optional, List

@dataclass
class Unit:
    id: Optional[int] = field(default=None)
    name: str = ""
    is_done: bool = False

@dataclass
class Project:
    id: Optional[int] = field(default=None)
    name: str = ""
    number: str = ""
    start_date: str = ""
    end_date: Optional[str] = None
    status: str = ""
    is_residential_complex: bool = False
    number_of_units: int = 0
    worker: str = ""
    extra: str = ""
    main_contractor: Optional[str] = None  # New Optional Attribute
    units: List[str] = field(default_factory=list)  # List of Unit Names

================
File: promptTips.txt
================
here is the full codebase, read it and tell me when your ready to make changes --- (repopack) ---









instructions

provide the full code for the parts you changed. do not explain it. Tell me when your done.

================
File: requirements.txt
================
# requirements.txt
PyQt5==5.15.4
SQLAlchemy==1.4.46
pywin32==303; platform_system == "Windows"
openpyxl==3.0.10
python-docx==0.8.11

================
File: utils.py
================
# File: utils.py
import os
import sys
import subprocess
from configparser import ConfigParser

# Load configuration
config = ConfigParser()
config.read('config.ini')

def sanitize_filename(filename):
    return "".join(c for c in filename if c.isalnum() or c in (" ", "_", "-")).rstrip()

def get_template_dir():
    return os.path.abspath(config['Paths']['template_dir'])

def get_project_dir():
    return os.path.abspath(config['Paths']['project_dir'])

def get_docx_temp_dir():
    return os.path.abspath(config['Paths']['docx_temp_dir'])

def get_logs_dir():
    return os.path.abspath(config['Paths']['logs_dir'])

def get_main_contractors_file():
    project_dir = get_project_dir()
    return os.path.join(project_dir, "main_contractors.txt")

def check_template_files():
    template_dir = get_template_dir()
    required_files = ["Innregulering.docx", "Sjekkliste.docx"]
    missing_files = [file for file in required_files if not os.path.exists(os.path.join(template_dir, file))]
    if missing_files:
        return False, f"Missing template files: {', '.join(missing_files)}"
    return True, "All template files are present."

def open_docx_file(filepath):
    try:
        if sys.platform.startswith('darwin'):
            subprocess.call(['open', filepath])
        elif os.name == 'nt':
            os.startfile(filepath)
        elif os.name == 'posix':
            subprocess.call(['xdg-open', filepath])
        return True, "Opened successfully."
    except Exception as e:
        return False, f"Failed to open file: {str(e)}"

def load_main_contractors():
    """
    Loads the list of main contractors from a text file.
    """
    contractors_file = get_main_contractors_file()
    if not os.path.exists(contractors_file):
        # If the file doesn't exist, create it with default contractors
        with open(contractors_file, 'w') as f:
            f.write("Lindal\nLohne\n")
    with open(contractors_file, 'r') as f:
        contractors = [line.strip() for line in f if line.strip()]
    return contractors

def add_main_contractor(contractor_name):
    """
    Adds a new main contractor to the storage file.
    """
    contractors_file = get_main_contractors_file()
    contractors = load_main_contractors()
    if contractor_name not in contractors:
        with open(contractors_file, 'a') as f:
            f.write(f"{contractor_name}\n")
